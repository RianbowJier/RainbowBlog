INSERT INTO `sg_article`(`id`, `title`, `content`, `summary`, `category_id`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_by`, `create_time`, `update_by`, `update_time`, `del_flag`) VALUES (1, 'SpringSecurity从入门到精通', '## 课程介绍\n![image20211219121555979.png](https://sg-blog-oss.oss-cn-beijing.aliyuncs.com/2022/01/31/e7131718e9e64faeaf3fe16404186eb4.png)\n\n## 0. 简介1\n\n​	**Spring Security** 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架**Shiro**，它提供了更丰富的功能，社区资源也比Shiro丰富。\n\n​	一般来说中大型的项目都是使用**SpringSecurity** 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。\n\n​	 一般Web应用的需要进行**认证**和**授权**。\n\n​		**认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户**\n\n​		**授权：经过认证后判断当前用户是否有权限进行某个操作**\n\n​	而认证和授权也是SpringSecurity作为安全框架的核心功能。\n\n\n\n## 1. 快速入门\n\n### 1.1 准备工作\n\n​	我们先要搭建一个简单的SpringBoot工程\n\n① 设置父工程 添加依赖\n\n~~~~\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.5.0</version>\n    </parent>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n    </dependencies>\n~~~~\n\n② 创建启动类\n\n~~~~\n@SpringBootApplication\npublic class SecurityApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SecurityApplication.class,args);\n    }\n}\n\n~~~~\n\n③ 创建Controller\n\n~~~~java\n\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class HelloController {\n\n    @RequestMapping(\"/hello\")\n    public String hello(){\n        return \"hello\";\n    }\n}\n\n~~~~\n\n\n\n### 1.2 引入SpringSecurity\n\n​	在SpringBoot项目中使用SpringSecurity我们只需要引入依赖即可实现入门案例。\n\n~~~~xml\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-security</artifactId>\n        </dependency>\n~~~~\n\n​	引入依赖后我们在尝试去访问之前的接口就会自动跳转到一个SpringSecurity的默认登陆页面，默认用户名是user,密码会输出在控制台。\n\n​	必须登陆之后才能对接口进行访问。\n\n\n\n## 2. 认证\n\n### 2.1 登陆校验流程\n![image20211215094003288.png](https://sg-blog-oss.oss-cn-beijing.aliyuncs.com/2022/01/31/414a87eeed344828b5b00ffa80178958.png)', 'SpringSecurity框架教程-Spring Security+JWT实现项目级前端分离认证授权', 1, 'https://sg-blog-oss.oss-cn-beijing.aliyuncs.com/2022/01/31/948597e164614902ab1662ba8452e106.png', '1', '0', 114, '0', NULL, '2022-01-23 23:20:11', NULL, NULL, 0);
INSERT INTO `sg_article`(`id`, `title`, `content`, `summary`, `category_id`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_by`, `create_time`, `update_by`, `update_time`, `del_flag`) VALUES (2, 'weq', 'adadaeqe', 'adad', 2, 'https://sg-blog-oss.oss-cn-beijing.aliyuncs.com/2022/01/15/fd2e9460c58a4af3bbeae5d9ed581688.png', '1', '0', 23, '0', NULL, '2022-01-21 14:58:30', NULL, NULL, 1);
INSERT INTO `sg_article`(`id`, `title`, `content`, `summary`, `category_id`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_by`, `create_time`, `update_by`, `update_time`, `del_flag`) VALUES (3, 'dad', 'asdasda', 'sadad', 1, 'https://sg-blog-oss.oss-cn-beijing.aliyuncs.com/2022/01/15/737a0ed0b8ea430d8700a12e76aa1cd1.png', '1', '0', 42, '0', NULL, '2022-01-18 14:58:34', NULL, NULL, 0);
INSERT INTO `sg_article`(`id`, `title`, `content`, `summary`, `category_id`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_by`, `create_time`, `update_by`, `update_time`, `del_flag`) VALUES (5, 'sdad', '![Snipaste_20220115_165812.png](https://sg-blog-oss.oss-cn-beijing.aliyuncs.com/2022/01/15/1d9d283f5d874b468078b183e4b98b71.png)\r\n\r\n## sda \r\n\r\n222\r\n### sdasd newnewnew', NULL, 2, '', '1', '0', 47, '0', NULL, '2022-01-17 14:58:37', NULL, NULL, 1);
INSERT INTO `sg_article`(`id`, `title`, `content`, `summary`, `category_id`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_by`, `create_time`, `update_by`, `update_time`, `del_flag`) VALUES (8, '测试发布文章', '## 你还要', '测试', 2, 'http://s5xzwt59m.hn-bkt.clouddn.com/2023/12/29/7089886070bd46f69d544d33c54a6f5f.jpg', '1', '0', 3, '0', 1, '2023-12-29 16:54:03', 1, '2023-12-29 16:54:03', 0);
INSERT INTO `sg_article`(`id`, `title`, `content`, `summary`, `category_id`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_by`, `create_time`, `update_by`, `update_time`, `del_flag`) VALUES (9, '数据类型', '## 基本数据类型\nJava 中有八大数据类型，可以将其分为数值类型、字符类型。\n\n1. **数值类型**\n\n| **数据类型** | **大小** | **取值范围** |\n| --- | --- | --- |\n| byte（字节） | 8位 | -128 ~ 127 |\n| short（短整数） | 16位 | -32,768 ~ 32,767 |\n| int（整数） | 32位 | $2^{31} ~ 2^{31} - 1$ |\n| long（长整数） | 64位 | $2^{63} ~ 2^{63} - 1$ |\n| float（单精度浮点数） | 32位 | 浮点数类型（小数），如2.0f |\n| double（双精度整数） | 64位 | 更高精度的浮点数类型，如2.0 |\n\n2. **字符类型**\n\n| **数据类型** | **大小** | **取值范围** |\n| --- | --- | --- |\n| char（字符） | 16位 | 用于表示Unicode字符，1字符=2个字节 |\n\n3. **布尔类型**\n\n| **数据类型** | **大小** | **取值范围** |\n| --- | --- | --- |\n| boolean（布尔） | 表示逻辑值 | true & false |\n\n\n## 为什么浮点运算的时候会有精度丢失的风险？\n浮点数运算精度丢失代码演示：\n```java\nfloat a = 2.0f - 1.9f;\nfloat b = 1.8f - 1.7f;\nSystem.out.println(a);       // 0.100000024\nSystem.out.println(b);       // 0.099999905\nSystem.out.println(a == b);  // false\n```\n为什么会出现这个问题呢？<br />这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。<br />**解决办法：**\n\n1. **BigDecimal**：使用BigDecimal类来进行高精度的十进制数值运算，可以精确表示和计算小数，而不会出现读点书的精度问题。\n```java\nimport java.math.BigDecimal;\n\nBigDecimal num1 = new BigDecimal(\"2.0\");\nBigDecimal num2 = new BigDecimal(\"1.1\");\nBigDecimal result = num1.subtract(num2);   //减法\nSystem.out.println(result);                //0.9\n```\n\n2. **限制小数位数**：如果你知道你的计算结果应该具有特定的小数位数，可以限制结果的小数位数，从而减少精度丢失。\n```java\ndouble result = 2.0 - 1.1; // 限制小数位数\nSystem.out.printf(\"%.2f%n\", result);\n```\n\n3. **尽量避免浮点数比较**：避免使用==或!=运算符来来比较两个浮点数，因为浮点数的精度问题可能导致不准确的结果。\n```java\ndouble num1 = 2.0;\ndouble num2 = 1.1;\ndouble epsilon = 1e-10; // 定义一个足够小的误差范围\nif (Math.abs(num1 - num2) < epsilon) {\n    // 数值相等\n}\n```\n`1e-10` 表示科学计数法中的一个小数，具体为 0.0000000001。这是一个非常接近零的小数，通常用于表示非常小的数值或误差范围，以在浮点数比较中避免精度问题。\n\n## 包装类型\n基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。\n\n| **基本数据类型** | **包装类** |\n| --- | --- |\n| boolean | Boolean |\n| char | Character |\n| byte | Byte |\n| short | Short |\n| int | Integer |\n| long | Long |\n| float | Float |\n| double | Double |\n\n### 体系图\n\n![image.png](http://s5xzwt59m.hn-bkt.clouddn.com/2023/12/30/675c89714c0944698c7c835ff51b5b28.png)\n\n![image.png](http://s5xzwt59m.hn-bkt.clouddn.com/2023/12/30/14b08d978c0a41a498f83cc277afbb5d.png)\n### 装箱和拆箱\n\n1. 装箱（Boxing）装箱是将基本数据类型转为对应的包装类对象的过程\n```java\nint primitiveInt = 42;\nInteger wrapperInt = primitiveInt; // 自动装箱  底层使用的是Integer.valueOf(primitiveInt)\n\n//或者显示装箱\nint primitiveInt = 42;\nInteger wrapperInt = Integer.valueOf(primitiveInt); // 手动装箱\n\n//字符串转为包装类\nString str = \"123\";\nInteger wrapperInt = Integer.valueOf(str);\n```\n\n2. 拆箱（Unboxing）拆箱是将包装类对象转为基本数据类型的过程\n```java\nInteger wrapperInt = 42;\nint primitiveInt = wrapperInt; // 自动拆箱\n\n//或者显示的拆箱\nInteger wrapperInt = 42;\nint primitiveInt = wrapperInt.intValue(); // 手动拆箱\n\n//包装类转为字符串\nInteger wrapperInt = 123;\nString str = wrapperInt.toString();\n```\n### 缓冲池\n#### new Integer(123) 与 Integer.valueOf(123) 的区别\n\n1. `new Integer(123) `每次都会新建一个对象\n2. `Integer.valueOf(123)` 会使用缓存池中的对象，多次调用会取得同一个对象的引用。\n```java\nInteger x = new Integer(123);\nInteger y = new Integer(123);\nSystem.out.println(x == y);    // false\nInteger z = Integer.valueOf(123);\nInteger k = Integer.valueOf(123);\nSystem.out.println(z == k);   // true\n```\n\n**源码分析**：\n```java\npublic static Integer valueOf(int i) {\n    // 检查参数 i 是否在 IntegerCache 缓存范围内，在JDK8中，缓冲池的默认大小是-128~127\n    if (i >= IntegerCache.low && i <= IntegerCache.high)\n        // 如果在缓存范围内，返回缓存中的 Integer 对象\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    \n    // 如果超出缓存范围，创建一个新的 Integer 对象并返回\n    return new Integer(i);\n}\n\n```\n**例如**：\n```java\nInteger num1 = Integer.valueOf(1); \nInteger num2 = Integer.valueOf(1); \nSystem.out.println(num1==num2);    //true，都指向同一个对象\n\nInteger num1 = Integer.valueOf(128); \nInteger num2 = Integer.valueOf(128); \nSystem.out.println(num1==num2);    //false，由于超过除了缓存范围，创建一个新Integer对象\n```\n\n### 为什么有包装类？\n\n1. 提供一种机制，将基本数据类型包装类对象，从而是基本数据类型能够保存在对象中，比如添加到Collections 中，或者从带对象返回值的方法中返回。\n\n\n## String 类型\n### 体系图\n\n![image.png](http://s5xzwt59m.hn-bkt.clouddn.com/2023/12/30/0700ef9bbbc74eba866cd4329d5d088e.png)!\n\n### 概述\n\nString 被声明为 **final**，因此它不可被继承。<br />内部使用 char 数组存储数据，该数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。\n\n**源码分析**：\n```java\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n    /** The value is used for character storage. */\n    private final char value[];\n```\n### 不同创建方式的内存分布\n\n1. **String str1=\"hello\"和String str2=new String(\"hello\")**\n```java\nString str1=\"hello\";   //对象存放在常量池中\nString str2=new String(\"hello\")  //对象存放在堆中\n```\n\n2. 第二种\n```java\nString s1=\"hello\"\ns1=\"hahah\"\n//在方法区的常量池中，实际上创建了两个对象：hello、hahah\n```\n\n3. 第三种\n```java\nString a=\"hello\"+\"world\";  //实际上只创建了一个对象：helloworld\n```\n\n4. 第四种\n```java\nString str1=\"hello\";\nString str2=\"world\";\nString str4=str1+str2;\n```\n\n   1. 当执行`String str4 = str1 + str2`，Java编译器会使用`StringBuilder`类来处理字符串的拼接。\n   2. `StringBuilder s=new StringBuilder()`对象，str1、str2的内容会复制到StringBuilder的缓存区中；\n   3. `sb.append(str1)、sb.append(str2)`；\n   4. `String str4=sb.toString()`；底层实际上是在**堆**中创建了一个对象；\n\n最后在**常量池**中创建了两个对象：hello、world，在**堆**中创建了一个对象：helloworld。\n\n### StringBuffer\n\n![image.png](http://s5xzwt59m.hn-bkt.clouddn.com/2023/12/30/2b801e2243f04b058f2fd1903d08fefa.png)!\n\n<br />StringBuffer 是一个可变的字符序列，是**线程安全**的。<br />\n\n**源码分析**：\n```java\nStringBuffer sb = new StringBuffer(\"hello\");\n```\n\n1. 首先初始化字符数组容量为 `str.length() + 16`\n    ```java\n    public final class StringBuffer\n        extends AbstractStringBuilder\n        implements Serializable, CharSequence{\n\n        /**\n        * A cache of the last value returned by toString. Cleared\n        * whenever the StringBuffer is modified.\n        */\n        private transient char[] toStringCache;  //内部使用 char 数组存储数据，并且没有 final 关键字修饰，说明内容可以被修改。\n\n        。。。。。。、\n        //构造方法\n        public StringBuilder(String str) {\n        super(str.length() + 16);   //1、初始化\n        append(str);\n        }	\n    }\n    ```\n    调用父类的**构造**方法\n    ```java\n    //父类\n    AbstractStringBuilder(int capacity) {\n        value = new char[capacity];   //此时数组容量为str.length() + 16\n    }\n    ```\n\n2. **调用 **`append`** 方法**\n    ```java\n    @Override\n    public synchronized StringBuffer append(String str) {   //方法被synchronized修饰，说明StringBuffer是线程安全的\n        toStringCache = null;\n        super.append(str);\n        return this;\n    }\n    ```\n    调用父类的 `append` 方法\n    ```java\n    public AbstractStringBuilder append(String str) {\n        if (str == null)\n            return appendNull();\n        int len = str.length();\n        ensureCapacityInternal(count + len);\n        str.getChars(0, len, value, count);\n        count += len;\n        return this;\n    }\n    ```\n\n3. 最后完成数据存储\n\n    ```java\n    StringBuffer sb = new StringBuffer(\"hello\");\n    ```\n\n\n\n### StringBuilder\n\n![image.png](http://s5xzwt59m.hn-bkt.clouddn.com/2023/12/30/61fef0bd04154346ae185322aeed27b0.png)\n\n<br />一个可变的字符序列。<br />StringBuilder 是**线程不安全**的，用在字符串缓冲区被**单个线程**使用的时候。<br />**源码分析**：\n```java\nStringBuffer sb = new StringBuffer(\"hello\");\n```\n\n1.  首先初始化字符数组容量为 `str.length() + 16`\n    ```java\n    public StringBuilder(String str) {\n        super(str.length() + 16);\n        append(str);\n    }\n    ```\n    调用父类的构造方法，完成字符数组初始化\n    ```java\n    AbstractStringBuilder(int capacity) {\n        value = new char[capacity];\n    }\n    ```\n\n2. 调用 `append`方法\n    ```java\n    @Override\n    public StringBuilder append(String str) {\n        super.append(str);\n        return this;\n    }\n    ```\n    调用父类的 `append` 方法，方法被没有被 `synchronized` 修饰，说明 StringBuilder是不线程安全的。\n    ```java\n    public AbstractStringBuilder append(String str) {\n        if (str == null)\n            return appendNull();\n        int len = str.length();\n        ensureCapacityInternal(count + len);\n        str.getChars(0, len, value, count);\n        count += len;\n        return this;\n    }\n    ```\n\n3. 最后完成数据存储\n    ```java\n    StringBuffer sb = new StringBuffer(\"hello\");\n    ```\n\n### String VS StringBuffer VS StringBuilder\n| **类型** | **说明** | **效率** | **优点** | **使用场景** |\n| --- | --- | --- | --- | --- |\n| String | 不可变的字符序列 | 低 | 复用率高 | 字符串很少修改 |\n| StringBuffer | 可变的字符序列 | 较高 | 线程安全 | 字符串存在大量修改，并在多线程 |\n| StringBuilder | 可变的字符序列 | 最高（单线程） | 线程不安全 | 字符串存在大量修改，并在单线程 |\n\n\n\n\n\n', NULL, 1, '', '0', '0', 5, '0', 1, '2023-12-30 20:41:18', 1, '2023-12-30 20:41:18', 0);
